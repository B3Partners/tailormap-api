<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapResponse.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tailormap API</a> &gt; <a href="index.source.html" class="el_package">nl.b3p.tailormap.api.model</a> &gt; <span class="el_source">MapResponse.java</span></div><h1>MapResponse.java</h1><pre class="source lang-java linenums">package nl.b3p.tailormap.api.model;

import java.net.URI;
import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import nl.b3p.tailormap.api.model.AppLayer;
import nl.b3p.tailormap.api.model.Bounds;
import nl.b3p.tailormap.api.model.CoordinateReferenceSystem;
import nl.b3p.tailormap.api.model.LayerTreeNode;
import nl.b3p.tailormap.api.model.Service;
import java.io.Serializable;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;


import java.util.*;
import javax.annotation.Generated;

/**
 * Any information needed to draw a basic map on a page. May include base layers.
 */

@Schema(name = &quot;MapResponse&quot;, description = &quot;Any information needed to draw a basic map on a page. May include base layers.&quot;)
@Generated(value = &quot;org.openapitools.codegen.languages.SpringCodegen&quot;)
<span class="fc" id="L33">public class MapResponse  implements Serializable {</span>

  private static final long serialVersionUID = 1L;

  @JsonProperty(&quot;initialExtent&quot;)
  private Bounds initialExtent;

  @JsonProperty(&quot;maxExtent&quot;)
  private Bounds maxExtent;

<span class="fc" id="L43">  @JsonProperty(&quot;services&quot;)</span>
  @Valid
  private Set&lt;Service&gt; services = new LinkedHashSet&lt;&gt;();

<span class="fc" id="L47">  @JsonProperty(&quot;baseLayerTreeNodes&quot;)</span>
  @Valid
  private List&lt;LayerTreeNode&gt; baseLayerTreeNodes = new ArrayList&lt;&gt;();

<span class="fc" id="L51">  @JsonProperty(&quot;layerTreeNodes&quot;)</span>
  @Valid
  private List&lt;LayerTreeNode&gt; layerTreeNodes = new ArrayList&lt;&gt;();

<span class="fc" id="L55">  @JsonProperty(&quot;appLayers&quot;)</span>
  @Valid
  private List&lt;AppLayer&gt; appLayers = new ArrayList&lt;&gt;();

  @JsonProperty(&quot;crs&quot;)
  private CoordinateReferenceSystem crs;

  public MapResponse initialExtent(Bounds initialExtent) {
<span class="fc" id="L63">    this.initialExtent = initialExtent;</span>
<span class="fc" id="L64">    return this;</span>
  }

  /**
   * Get initialExtent
   * @return initialExtent
  */
  @NotNull @Valid 
  @Schema(name = &quot;initialExtent&quot;, required = true)
  public Bounds getInitialExtent() {
<span class="fc" id="L74">    return initialExtent;</span>
  }

  public void setInitialExtent(Bounds initialExtent) {
<span class="nc" id="L78">    this.initialExtent = initialExtent;</span>
<span class="nc" id="L79">  }</span>

  public MapResponse maxExtent(Bounds maxExtent) {
<span class="fc" id="L82">    this.maxExtent = maxExtent;</span>
<span class="fc" id="L83">    return this;</span>
  }

  /**
   * Get maxExtent
   * @return maxExtent
  */
  @Valid 
  @Schema(name = &quot;maxExtent&quot;, required = false)
  public Bounds getMaxExtent() {
<span class="fc" id="L93">    return maxExtent;</span>
  }

  public void setMaxExtent(Bounds maxExtent) {
<span class="nc" id="L97">    this.maxExtent = maxExtent;</span>
<span class="nc" id="L98">  }</span>

  public MapResponse services(Set&lt;Service&gt; services) {
<span class="nc" id="L101">    this.services = services;</span>
<span class="nc" id="L102">    return this;</span>
  }

  public MapResponse addServicesItem(Service servicesItem) {
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">    if (this.services == null) {</span>
<span class="nc" id="L107">      this.services = new LinkedHashSet&lt;&gt;();</span>
    }
<span class="fc" id="L109">    this.services.add(servicesItem);</span>
<span class="fc" id="L110">    return this;</span>
  }

  /**
   * Get services
   * @return services
  */
  @NotNull @Valid 
  @Schema(name = &quot;services&quot;, required = true)
  public Set&lt;Service&gt; getServices() {
<span class="fc" id="L120">    return services;</span>
  }

  @JsonDeserialize(as = LinkedHashSet.class)
  public void setServices(Set&lt;Service&gt; services) {
<span class="nc" id="L125">    this.services = services;</span>
<span class="nc" id="L126">  }</span>

  public MapResponse baseLayerTreeNodes(List&lt;LayerTreeNode&gt; baseLayerTreeNodes) {
<span class="nc" id="L129">    this.baseLayerTreeNodes = baseLayerTreeNodes;</span>
<span class="nc" id="L130">    return this;</span>
  }

  public MapResponse addBaseLayerTreeNodesItem(LayerTreeNode baseLayerTreeNodesItem) {
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">    if (this.baseLayerTreeNodes == null) {</span>
<span class="nc" id="L135">      this.baseLayerTreeNodes = new ArrayList&lt;&gt;();</span>
    }
<span class="fc" id="L137">    this.baseLayerTreeNodes.add(baseLayerTreeNodesItem);</span>
<span class="fc" id="L138">    return this;</span>
  }

  /**
   * Unordered list of all tree nodes of base layers. Start with the node with root set to true and use the ordered children array property to order the tree. For base layers, only one child node (with all its' child layers) of the root should be displayed at one time.
   * @return baseLayerTreeNodes
  */
  @NotNull @Valid 
  @Schema(name = &quot;baseLayerTreeNodes&quot;, description = &quot;Unordered list of all tree nodes of base layers. Start with the node with root set to true and use the ordered children array property to order the tree. For base layers, only one child node (with all its' child layers) of the root should be displayed at one time.&quot;, required = true)
  public List&lt;LayerTreeNode&gt; getBaseLayerTreeNodes() {
<span class="fc" id="L148">    return baseLayerTreeNodes;</span>
  }

  public void setBaseLayerTreeNodes(List&lt;LayerTreeNode&gt; baseLayerTreeNodes) {
<span class="nc" id="L152">    this.baseLayerTreeNodes = baseLayerTreeNodes;</span>
<span class="nc" id="L153">  }</span>

  public MapResponse layerTreeNodes(List&lt;LayerTreeNode&gt; layerTreeNodes) {
<span class="nc" id="L156">    this.layerTreeNodes = layerTreeNodes;</span>
<span class="nc" id="L157">    return this;</span>
  }

  public MapResponse addLayerTreeNodesItem(LayerTreeNode layerTreeNodesItem) {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">    if (this.layerTreeNodes == null) {</span>
<span class="nc" id="L162">      this.layerTreeNodes = new ArrayList&lt;&gt;();</span>
    }
<span class="fc" id="L164">    this.layerTreeNodes.add(layerTreeNodesItem);</span>
<span class="fc" id="L165">    return this;</span>
  }

  /**
   * Unordered list of all tree nodes of overlay/thematic/transparent layers. Start with the node with root set to true and use the ordered children array property to order the tree.
   * @return layerTreeNodes
  */
  @NotNull @Valid 
  @Schema(name = &quot;layerTreeNodes&quot;, description = &quot;Unordered list of all tree nodes of overlay/thematic/transparent layers. Start with the node with root set to true and use the ordered children array property to order the tree.&quot;, required = true)
  public List&lt;LayerTreeNode&gt; getLayerTreeNodes() {
<span class="fc" id="L175">    return layerTreeNodes;</span>
  }

  public void setLayerTreeNodes(List&lt;LayerTreeNode&gt; layerTreeNodes) {
<span class="nc" id="L179">    this.layerTreeNodes = layerTreeNodes;</span>
<span class="nc" id="L180">  }</span>

  public MapResponse appLayers(List&lt;AppLayer&gt; appLayers) {
<span class="nc" id="L183">    this.appLayers = appLayers;</span>
<span class="nc" id="L184">    return this;</span>
  }

  public MapResponse addAppLayersItem(AppLayer appLayersItem) {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">    if (this.appLayers == null) {</span>
<span class="nc" id="L189">      this.appLayers = new ArrayList&lt;&gt;();</span>
    }
<span class="fc" id="L191">    this.appLayers.add(appLayersItem);</span>
<span class="fc" id="L192">    return this;</span>
  }

  /**
   * Unordered list of all AppLayers referenced from baseLayerTreeNodes and layerTreeNodes. Note that you need to lookup these by id, but OpenAPI only supports a map by using strings as keys, so an array is used instead.
   * @return appLayers
  */
  @NotNull @Valid 
  @Schema(name = &quot;appLayers&quot;, description = &quot;Unordered list of all AppLayers referenced from baseLayerTreeNodes and layerTreeNodes. Note that you need to lookup these by id, but OpenAPI only supports a map by using strings as keys, so an array is used instead.&quot;, required = true)
  public List&lt;AppLayer&gt; getAppLayers() {
<span class="fc" id="L202">    return appLayers;</span>
  }

  public void setAppLayers(List&lt;AppLayer&gt; appLayers) {
<span class="nc" id="L206">    this.appLayers = appLayers;</span>
<span class="nc" id="L207">  }</span>

  public MapResponse crs(CoordinateReferenceSystem crs) {
<span class="fc" id="L210">    this.crs = crs;</span>
<span class="fc" id="L211">    return this;</span>
  }

  /**
   * Get crs
   * @return crs
  */
  @NotNull @Valid 
  @Schema(name = &quot;crs&quot;, required = true)
  public CoordinateReferenceSystem getCrs() {
<span class="fc" id="L221">    return crs;</span>
  }

  public void setCrs(CoordinateReferenceSystem crs) {
<span class="nc" id="L225">    this.crs = crs;</span>
<span class="nc" id="L226">  }</span>

  @Override
  public boolean equals(Object o) {
<span class="nc bnc" id="L230" title="All 2 branches missed.">    if (this == o) {</span>
<span class="nc" id="L231">      return true;</span>
    }
<span class="nc bnc" id="L233" title="All 4 branches missed.">    if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L234">      return false;</span>
    }
<span class="nc" id="L236">    MapResponse mapResponse = (MapResponse) o;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">    return Objects.equals(this.initialExtent, mapResponse.initialExtent) &amp;&amp;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        Objects.equals(this.maxExtent, mapResponse.maxExtent) &amp;&amp;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        Objects.equals(this.services, mapResponse.services) &amp;&amp;</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        Objects.equals(this.baseLayerTreeNodes, mapResponse.baseLayerTreeNodes) &amp;&amp;</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        Objects.equals(this.layerTreeNodes, mapResponse.layerTreeNodes) &amp;&amp;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        Objects.equals(this.appLayers, mapResponse.appLayers) &amp;&amp;</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        Objects.equals(this.crs, mapResponse.crs);</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L248">    return Objects.hash(initialExtent, maxExtent, services, baseLayerTreeNodes, layerTreeNodes, appLayers, crs);</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L253">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L254">    sb.append(&quot;class MapResponse {\n&quot;);</span>
<span class="nc" id="L255">    sb.append(&quot;    initialExtent: &quot;).append(toIndentedString(initialExtent)).append(&quot;\n&quot;);</span>
<span class="nc" id="L256">    sb.append(&quot;    maxExtent: &quot;).append(toIndentedString(maxExtent)).append(&quot;\n&quot;);</span>
<span class="nc" id="L257">    sb.append(&quot;    services: &quot;).append(toIndentedString(services)).append(&quot;\n&quot;);</span>
<span class="nc" id="L258">    sb.append(&quot;    baseLayerTreeNodes: &quot;).append(toIndentedString(baseLayerTreeNodes)).append(&quot;\n&quot;);</span>
<span class="nc" id="L259">    sb.append(&quot;    layerTreeNodes: &quot;).append(toIndentedString(layerTreeNodes)).append(&quot;\n&quot;);</span>
<span class="nc" id="L260">    sb.append(&quot;    appLayers: &quot;).append(toIndentedString(appLayers)).append(&quot;\n&quot;);</span>
<span class="nc" id="L261">    sb.append(&quot;    crs: &quot;).append(toIndentedString(crs)).append(&quot;\n&quot;);</span>
<span class="nc" id="L262">    sb.append(&quot;}&quot;);</span>
<span class="nc" id="L263">    return sb.toString();</span>
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
<span class="nc bnc" id="L271" title="All 2 branches missed.">    if (o == null) {</span>
<span class="nc" id="L272">      return &quot;null&quot;;</span>
    }
<span class="nc" id="L274">    return o.toString().replace(&quot;\n&quot;, &quot;\n    &quot;);</span>
  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>