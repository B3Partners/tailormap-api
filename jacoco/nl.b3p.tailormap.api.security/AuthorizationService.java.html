<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AuthorizationService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Aggregate Test Coverage</a> &gt; <a href="index.source.html" class="el_package">nl.b3p.tailormap.api.security</a> &gt; <span class="el_source">AuthorizationService.java</span></div><h1>AuthorizationService.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2022 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */
package nl.b3p.tailormap.api.security;

import nl.b3p.tailormap.api.persistence.Application;
import org.springframework.stereotype.Service;

/**
 * Validates access control rules. Any call to mayUserRead will verify that the currently logged in
 * user is not only allowed to read the current object, but any objcet above and below it in the
 * hierarchy.
 */
@Service
<span class="nc" id="L17">public class AuthorizationService {</span>

  /**
   * Verifies that the user may read the object, based on the passed in readers set.
   *
   * @param readers the list of readers to validate against.
   * @return the result of validating the authorizations.
   */
  /*  private boolean isAuthorizedBySet(Set&lt;String&gt; readers) {

    return true;

    if (readers == null || readers.isEmpty()) {
      return true;
    }

    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
    if (auth == null) {
      return false;
    }

    for (String reader : readers) {
      if (auth.getAuthorities().stream().anyMatch(x -&gt; x.getAuthority().equals(reader))) {
        return true;
      }
    }

    return false;
  }*/

  /**
   * Verifies that this user may read this Application.
   *
   * @param application the Application to check
   * @return the results from the access control checks.
   */
  public boolean mayUserRead(Application application) {
<span class="nc" id="L54">    return true;</span>
    /*    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
    if ((authentication == null || authentication instanceof AnonymousAuthenticationToken)
        &amp;&amp; application.isAuthenticatedRequired()) {
      return false;
    }

    return isAuthorizedBySet(application.getReaders());*/
  }

  /**
   * Verifies that this user may view an ApplicationLayer in the context of a certain Application.
   * As an ApplicationLayer cannot be traced back to a single Application (e.g. mashups), this
   * requires passing in the Application to use as context. The ApplicationLayer, its parent Levels,
   * and the Application are validated, as are the Layer, all its parents, and the GeoService.
   *
   * @param applicationLayer the ApplicationLayer to check
   * @param context the Application to verify this ApplicationLayer against
   * @return the results from the access control checks.
   */
  /*  public boolean mayUserRead(ApplicationLayer applicationLayer, Application context) {
    if (!isAuthorizedBySet(applicationLayer.getReaders())) {
      return false;
    }

    if (!mayUserRead(context)) {
      return false;
    }

    Set&lt;Long&gt; levelIds = new HashSet&lt;&gt;();
    for (Level level : levelRepository.findByLevelTree(context.getRoot().getId())) {
      levelIds.add(level.getId());
    }

    Level closestLevel = null;
    for (Level level : levelRepository.findWithAuthorizationDataByIdIn(levelIds)) {
      if (level.getLayers().contains(applicationLayer)) {
        closestLevel = level;
        break;
      }
    }

    if (closestLevel == null) {
      // layer ID does not exist in this application.
      return false;
    }

    if (!mayUserRead(closestLevel)) {
      return false;
    }

    GeoService geoService = applicationLayer.getService();
    if (geoService == null) {
      return true;
    }

    if (this.isProxiedSecuredServiceLayerInPublicApplication(context, applicationLayer)) {
      return false;
    }

    return mayUserRead(
        layerRepository.getByServiceAndName(geoService, applicationLayer.getLayerName()));
  }*/

  /**
   * When a service is proxied with a username and password, authentication must be required for the
   * application otherwise access to the layer should be denied to prevent an app admin accidentally
   * publishing private data from a secured service in a public application. This method checks
   * whether this is the case for a certain ApplicationLayer in the context of an Application.
   *
   * @param application the application (can be a mashup)
   * @param applicationLayer the application layer (may belong to a parent application)
   * @return see above
   */
  /*  public boolean isProxiedSecuredServiceLayerInPublicApplication(
          Application application, ApplicationLayer applicationLayer) {
    GeoService geoService = applicationLayer.getService();
    if (geoService == null) {
      return false;
    }
    if (Boolean.parseBoolean(
        String.valueOf(geoService.getDetails().get(GeoService.DETAIL_USE_PROXY)))) {
      boolean isSecuredService =
          geoService.getUsername() != null &amp;&amp; geoService.getPassword() != null;
      return isSecuredService &amp;&amp; !application.isAuthenticatedRequired();
    } else {
      return false;
    }
  }*/

  /**
   * Verifies that this user may view a Layer. The Layer, its parents, and the GeoService are all
   * validated.
   *
   * @param layer the Layer to check
   * @return the results from the access control checks.
   */
  /*  public boolean mayUserRead(Layer layer) {
    if (!isAuthorizedBySet(layer.getReaders())) {
      return false;
    }

    if (!mayUserRead(layer.getService())) {
      return false;
    }

    if (layer.getParent() != null) {
      return mayUserRead(layer.getParent());
    }

    return true;
  }*/

  /**
   * Verifies that this user may view a Level. The Level and its parents are all validated.
   *
   * @param level the Level to check
   * @return the results from the access control checks.
   */
  /*  public boolean mayUserRead(Level level) {
    if (!isAuthorizedBySet(level.getReaders())) {
      return false;
    }

    if (level.getParent() != null) {
      return mayUserRead(level.getParent());
    }

    return true;
  }*/

  /**
   * Verifies that this user may view a GeoService. The GeoService is validated.
   *
   * @param geoService the GeoService to check
   * @return the results from the access control checks.
   */
  /*  public boolean mayUserRead(GeoService geoService) {
    return isAuthorizedBySet(geoService.getReaders());
  }*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>